# Four in a Square (ארבע בריבוע) — Python Backend (кратко, RU)

Backend API для игры **“Four in a Square”** (горошины/шарики + сдвиг “плиток”).
Сервер — **источник истины**: проверяет правила и валидирует ходы, а также играет за **AI-соперника (Blue)**.

---

## Реализованные правила

### Поле
- 3×3 сетка **квадратов** (всего 9, `squareIndex: 0..8`)
- В каждом квадрате мини‑сетка **2×2** (4 ячейки, `slotIndex: 0..3`)
- Итого **36** ячеек
- **8 “плиток” + 1 пустое место** (как “пятнашки” / 8‑puzzle). Пустое место стартует в `squareIndex = 4` (центр).

### Нумерация ячеек внутри квадрата

```
 0 | 1
---|---
 2 | 3
```

### Нумерация квадратов (3×3)

```
 0 | 1 | 2
---|---|---
 3 | 4 | 5      <-- 4 = “дырка” (пустой квадрат)
---|---|---
 6 | 7 | 8
```

### Игроки
- Red = `"R"` — **человек** (клиент)
- Blue = `"B"` — **AI** (сервер)
- Red ходит первым

### Фишки
- По умолчанию **16** на игрока (настраивается через `piecesPerPlayer`, максимум 16)

### Ход игрока
Один ход состоит из **двух обязательных действий**:
1) **Поставить** 1 фишку своего цвета в любую **пустую ячейку** (не в квадрат‑дырку)
2) **Сдвинуть** один соседний квадрат в **дырку** (как в 8‑puzzle). Все фишки внутри квадрата **“едут” вместе с ним**.

Сдвиг возможен только из квадратов, **соседних с дыркой** (вверх/вниз/влево/вправо). Диагонали нельзя.

### Фазы
- `placement`: нужно **поставить** фишку
- `placementSlide`: фишка уже поставлена; нужно **сдвинуть** квадрат в дырку
- `movement`: все фишки выставлены; каждый ход — **только сдвиг** (без постановки)

Когда оба игрока поставили все фишки, фаза становится `movement`.

### Победа
Игрок выигрывает, если соберёт **сплошной блок 2×2** своего цвета **где угодно** на глобальной мини‑сетке **6×6**.
Это может быть:
- внутри одного квадрата
- на границе двух соседних квадратов
- на пересечении четырёх квадратов

#### Привязка к глобальным координатам

```
globalRow = squareRow * 2 + miniRow      (0..5)
globalCol = squareCol * 2 + miniCol      (0..5)

squareRow = floor(squareIndex / 3)
squareCol = squareIndex % 3
miniRow   = floor(slotIndex / 2)
miniCol   = slotIndex % 2
```

### Конец без ходов
В фазе `movement`, если у текущего игрока **нет ни одного легального сдвига**, игра заканчивается **ничьёй (DRAW)**.

---

## Запуск локально

```bash
pip install -r requirements.txt
uvicorn app.main:app --reload
```

API: `http://127.0.0.1:8000`

## Тесты

```bash
pytest
```

---

## API (кратко)

### GameState (возвращается всеми эндпоинтами)

```json
{
  "board": [[null, "R", null, null], [null, null, null, null], "...9 arrays total"],
  "phase": "placement",
  "currentPlayer": "R",
  "placed": { "R": 0, "B": 0 },
  "piecesPerPlayer": 8,
  "holeSquareIndex": 4,
  "winner": null,
  "drawReason": null
}
```

- `board`: массив из 9 массивов по 4 значения (`null | "R" | "B"`)
- доступ: `board[squareIndex][slotIndex]`
- `holeSquareIndex`: индекс квадрата‑дырки (`0..8`)

### POST `/games` — создать игру
Запрос:

```json
{ "piecesPerPlayer": 16 }
```

Ответ:

```json
{ "gameId": "abc123", "playerToken": "tok_xxx", "state": { "...GameState..." } }
```

### GET `/games/{game_id}` — получить состояние
Ответ:

```json
{ "state": { "...GameState..." } }
```

### POST `/games/{game_id}/move` — сделать ход
Клиент отправляет действие человека. Сервер:
1) валидирует и применяет действие
2) проверяет победу/ничью
3) если игра не закончена и ход AI — AI делает свой ход(ы)
4) возвращает обновлённое состояние (после хода человека и AI)

Постановка фишки (phase = `placement`):

```json
{ "action": "place", "squareIndex": 0, "slotIndex": 2, "playerToken": "tok_xxx" }
```

Сдвиг квадрата (phase = `placementSlide` или `movement`):

```json
{ "action": "slide", "squareIndex": 3, "playerToken": "tok_xxx" }
```

`squareIndex` — квадрат, который сдвигается **в дырку** (должен быть соседним к `holeSquareIndex`).

### POST `/games/{game_id}/restart` — перезапуск
Ответ:

```json
{ "state": { "...fresh GameState..." } }
```

---

## Поток “клиент → сервер” (кратко)

### Во время placement (каждый ход человека = 2 запроса)
1) `place` → сервер возвращает `phase: "placementSlide"`
2) `slide` → сервер применяет сдвиг, затем AI делает свой ход (place+slide), возвращается итоговое состояние

### Во время movement (каждый ход человека = 1 запрос)
1) `slide` → сервер применяет сдвиг, затем AI делает сдвиг, возвращается итоговое состояние

